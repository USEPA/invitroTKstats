---
title: "invitroTKstats Plotting Functions Demonstration"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{plotting-invitroTKstats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
The goal of this vignette is to showcase the two plotting functions in `invitroTKstats`, namely `plot_clint` and `plot_fup_uc`. The input data for these two functions should be Level-2 data. Level-2 data is Level-1 data returned from `format_clint` and `format_fup_uc`, respectively, then curated with a verification column. "Y" in the verification column indicates the data row is valid for analysis and plotting. 

## Set up
```{r setup, warning=FALSE, message=FALSE}
library(invitroTKstats)
library(ggplot2)
library(gridExtra)
library(tidyverse)
library(gridtext)
```

## plot_clint.R
`plot_clint` generates a time-versus-response scatter plot for a specified chemical. The data set used in this example is `kreutz2023.clint`. 
```{r example clint single, fig.width=5, fig.height=4}
# Load data in 
level2.clint <- invitroTKstats::kreutz2023.clint

# keep only the verified data
verified_data_clint <- level2.clint[level2.clint$Verified == "Y", ]

id <- unique(verified_data_clint$DTXSID)[9]
plot_clint(verified_data_clint, id)
```

**Figure 1:** This figure is an example of plots generated by `plot_clint`. The DTXSID of the compound is displayed in the title and the compound name is displayed on the bottom center. Each point represents a response and is labeled with different shapes by sample types and colored by calibrations. 

The following codes demonstrate how to put multiple plots in a grid when plotting for multiple compounds is desired. Each individual plot comes with a legend that is unique to the calibrations exist in a compound's data, thus common legend is less recommended. Adjusting the legend size is recommended and how to do so is showed below. 
```{r example clint multiple, warning=FALSE, fig.width=7, fig.height=7}
# plot the first four chemicals 
p <- list()
for (id in unique(verified_data_clint$DTXSID)[1:4]) {
  p[[id]] <- plot_clint(verified_data_clint, id) + 
    theme(legend.title = element_text(size = 6),
          legend.text = element_text(size = 6),
          plot.title = element_text(size=7))
}
do.call(grid.arrange,p)
```

**Figure 2:** These four plots are examples of plots generated by `plot_clint`. The font sizes of the legend titles and texts are set to be smaller for better visualization in a grid. 

## plot_fup_uc.R
`plot_fup_uc` generates a response by sample type plot for a specified chemical. The data set used in this example is `kreutz2023.uc`. 
```{r example fup_uc single, fig.width=5, fig.height=4}
# load in data
level2.uc <- invitroTKstats::kreutz2023.uc

# keep only the verified data
verified_data_uc <- level2.uc[level2.uc$Verified == "Y", ]

id <- unique(verified_data_uc$DTXSID)[4]
plot_fup_uc(verified_data_uc, id)
```

**Figure 3:** This figure is an example of plots generated by `plot_fup_uc`. The DTXSID of the compound is displayed in the title and the compound name is displayed on the bottom center. Each box plot shows the distribution of responses by sample types and calibrations, and it is overlaid by the data points that represent the responses. The box plot outlines and the points are colored by calibrations.

The following codes demonstrate how to put multiple plots in a grid when having to show multiple compounds is desired. The y-axis label is a little lengthy and may not be suitable for multiple plots situation. Codes below show how users can utilize common axis label to prevent overlaps with `grid.arrange`. 

```{r example fup_uc, fig.height=7, fig.width=7}
# plot the first four chemicals 
p2 <- list()
for (id in unique(verified_data_uc$DTXSID)[1:4]) {
  p2[[id]] <- plot_fup_uc(verified_data_uc, id) + 
    theme(legend.title = element_text(size = 6),
          legend.text = element_text(size = 6),
          plot.title = element_text(size=7))
}

# remove the y-axis labels from all plots
p2 = p2 %>% map(~.x + labs(y=NULL))
# create an universal label
yleft = richtext_grob("Mass Spec. Intensity / Fraction Unbound", rot=90)
grid.arrange(grobs=p2, ncol = 2, nrow = 2, left = yleft)
```

**Figure 4:** These four plots are examples of plots generated by `plot_fup_uc`. The font sizes of the legend titles and texts are set to be smaller for better visualization in a grid. The grid uses a shared y-axis label on the left. 

By default, the plot compares responses across sample types. The plot can get overwhelmed when there are too many calibrations. In that case, facet by calibrations is a recommended option. 
```{r, fig.width=5, fig.height=4}
dtxsid <- unique(verified_data_uc$DTXSID)[8]
p3 <- plot_fup_uc(verified_data_uc, dtxsid)
p3
```

**Figure 5:** Example of what the plot generated by `plot_fup_uc` looks like when there are too many calibrations.

```{r, fig.width=5, fig.height=4}
p3 <- plot_fup_uc(verified_data_uc, dtxsid) + facet_wrap(~Calibration)
p3
```

**Figure 6:** Plot generated by `plot_fup_uc` compares responses by calibrations by default. Facet the plot by calibration to create a separate plot for each calibration.

There is an argument `compare` to change the plot to compare responses across calibrations (set `compare = "Cal"`). With this setting, users can also choose facet by sample types. 
```{r, fig.width=7, fig.height=7}
p4 <- plot_fup_uc(verified_data_uc, dtxsid, compare = "cal")
p5 <- p4 + facet_wrap(~Sample.Type)

grid.arrange(p4, p5)
```

**Figure 7:** These two plots are examples of plots generated by `plot_fup_uc` when changed the setting to compare responses across calibrations. The plot on the left is the original plot and the plot on the right is the original plot faceted by sample types.
